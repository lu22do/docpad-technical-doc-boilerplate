```
title: Application Developer Guide
layout: guide
tags: ['guide']
pageOrder: 1
```

# OpenTV 5 Application Developer’s Guide

## Overview

### Audience

This document is intended for developers using OpenTV5 to create HTML
applications. The reader is expected to be familiar with the JavaScript
programming language, HTML, CSS, and general object-oriented software
programming principles.

### Custom vs Standards

This documentation covers:

* Unique features of OpenTV5, and
* Deviations from standard HTML/JavaScript norms.

For general, non-specific information about HTML/JavaScript usage, refer
to one of many web resources, such as [*http://www.w3schools.com/*](http://www.w3schools.com/), for tutorials and specifications.

The *OpenTV 5 HTML Advanced Developer’s Guide* is also included in this
documentation set: refer to it for detailed advice about how to build
efficient applications using OpenTV WebKit, particularly techniques to
maximize performance on a hardware-limited embedded device such as a
set-top box.

## OpenTV WebKit

The main application development environment supported by OpenTV 5 is
OpenTV WebKit, a native WebKit­based browser and runtime environment.
OpenTV 5.1.4 has been updated to use OpenTV WebKit version 1.1.

The Ekioh browser previously provided for SVG-based development is now
deprecated, and described in [Appendix: Ekioh Browser \[Deprecated\]](http://otv5docs/CCOM5.1.4/Support/Application%20Developer's%20Guide.htm#Racbabiecfj).

### Supported Features

Standard features:

* HTML5
* CSS3
* Hardware-accelerated animations
* Video Playback using the standard `<video>` tag
* Web Inspector
* Cookies
* Same Origin Policy
* Web Worker
* Web Au
* Media Source Extensions (MSE)
* Encrypted Media Extensions (EME)

OpenTV 5-specific features:

* A JavaScript API (CCOM):  Allows applications to access the Middleware features of OpenTV5.
* Alerts: When using OpenTV WebKit, use `console.log`
instead of `alert` to output data to the console
log.
* Remote Controller keys
* Comprehensive debugging tools increasing debugging performance and
development efficiency.
* DSMCC (Digital storage media command and control)\
A protocol for simple data broadcasting and broadcast files systems.

### Running

To run an application on OpenTV WebKit:

* Prepare the html application package, edit the *OTVAppMetadata.xml* file, and set the `<APP_TYPE>` to "html" (`<APP_TYPE>html</APP_TYPE>`)

* Install and run the application using the Application Controller
(refer to the [Application Installation](#application-installation)
section for details).

### Logging

OpenTV WebKit uses the OpenTV 5 `log` function to save internal (and other types) of logs coming from various types of JavaScript messages, including `alert`, `console.log`, `confirm` and `prompt`.

The OpenTV WebKit log format is:

    STATUS : [OtvWebKit] [XXXX] code location : message

Where:

* `STATUS : \[OtvWebKit\]\` is generated by the OTV log function automatically.

* `XXXX\` is the log type, including "CONSOLE LOG", "ALERT", "CONFIRM" or
"PROMPT".

* `code location` is an optional JavaScript code location information, including the file name and line number. This information is disabled by default, and outputs only in verbose log mode. Refer to the *OpenTV 5 HTML Advanced Developer’s Guide* for details about how to modify the *otvwebkit-config.xml* file to enable the `<js-log-verbose>` setting.

* `message` is a user-specified message in the JS API or Webkit message.

### Map a New Remote Control

To map a new remote control, follow this procedure:

1. Edit lircd.conf, a file normally located at /etc/lirc/lircd.conf or
/etc/lircd.conf on the target file system.

1. The lircd.conf file consists of pairs of string names and numerical
values.

1. The lircd.conf string names are located in the “LIRC Key Name” column
of the key mapping table.

1. HTML applications receive the numerical key values indicated by the
“OpenTV WebKit Key Codes” columns.

Commonly used remote control key codes:

| Key Name | OpenTV WebKit keydown keyCode (HEX) | OpenTV WebKit keydown keyCode (DEC) | Comments |
|---|---|---|---|
| 0 | 0x30 | 48 |  |
| 1 | 0x31 | 49 |  |
| 2 | 0x32 | 50 |  |
| 3 | 0x33 | 51 |  |
| 4 | 0x34 | 52 |  |
| 5 | 0x35 | 53 |  |
| 6 | 0x36 | 54 |  |
| 7 | 0x37 | 55 |  |
| 8 | 0x38 | 56 |  |
| 9 | 0x39 | 57 |  |
| AUDIO | 0xF037 | 61495 |  |
| AUX | 0xF034 | 61492 |  |
| BACK | 0xA6 | 166 | Back |
| BACKSPACE | 0x08 | 8 | Backspace |
| BLUE | 0x196 | 406 | Blue |
| CHANNEL_DOWN | 0x1AC | 428 |  |
| CHANNEL_UP | 0x1AB | 427 |  |
| CURSOR_DOWN | 0x28 | 40 | Arrow |
| CURSOR_LEFT | 0x25 | 37 | Arrow |
| CURSOR_RIGHT | 0x27 | 39 | Arrow |
| CURSOR_UP | 0x26 | 38 | Arrow |
| DVD | 0xF033 | 61491 |  |
| EJECT | 0x19E | 414 |  |
| ENTER | 0x0D | 13 | OK/ENTER/SELECT |
| EPG | 0x1CA | 458 | Guide |
| EXIT | 0x259 | 601 | Exit |
| FASTFORWARD | 0x1A1 | 417 | >> |
| FAVORITES | 0xAB | 171 |  |
| GREEN | 0x194 | 404 | Green |
| INFO | 0x1C9 | 457 | Info |
| LANGUAGE | 0xF01E | 61470 |  |
| LAST | 0xF04B | 61515 | Last |
| MENU | 0x5D | 93 | Menu |
| MHP | 0xAC | 172 | YouTube |
| MUTE | 0xAD | 173 |  |
| NEXT | 0xB0 | 176 | >>|
| OK | 0x0D | 13 | Not |
| PAGE_DOWN | 0x22 | 34 |  |
| PAGE_UP | 0x21 | 33 |  |
| PAUSE | 0x13 | 19 |  |
| PLAY | 0xFA | 250 |  |
| PLAYPAUSE | 0xB3 | 179 |  |
| POWER | 0x199 | 409 |  |
| PREVIOUS | 0xB1 | 177 | << |
| PVR | 0xF01C | 61468 | DVR |
| RECORD | 0x1A0 | 416 |  |
| RED | 0x193 | 403 |  |
| RETURN | 0x0D | 13 | OK/ENTER/SELECT |
| REWIND | 0x19C | 412 | << |
| SAT | 0xF02B | 61483 |  |
| SLOW | 0x1A3 | 419 | Slow |
| STOP | 0xB2 | 178 |  |
| SUBTITLE | 0x1CC | 460 | Subtitle, |
| TV | 0xF027 | 61479 |  |
| VCR | 0xF029 | 61481 |  |
| VIDEO | 0xF038 | 61496 |  |
| VOLUME_DOWN | 0xAE | 174 |  |
| VOLUME_UP | 0xAF | 175 |  |
| YELLOW | 0x195 | 405 | Yellow |
| ZOOM | 0xFB | 251 | Zoom |

Refer to the [*HTML Key Mappings*](#html-key-mappings) table in the appendix for less common keys.

#### Key Mapping Example Adding new Keys

Some remote control keys have no clear equivalent, for those we
recommend using custom keys. For example, to add buttons for VOD and
PIP, add the following to *lircd.conf*.

    CUSTOM0 0xfc03ff00
    CUSTOM1 0xbd42ff00

> (Note the actual values may vary across remotes.)

In the JavaScript application, listen for "keydown" events, as in this
example:

    // Add event listener to listen for key input
    document.addEventListener("keydown", keyEvent, false);

    function keyEvent(evt)
    {
        if(evt.type == "keydown")
        {
            console.log("keydown keyCode = " + evt.keyCode);

            if(evt.keyCode == 0xF500)
            {
                console.log("Received VOD key");
            }

            if(evt.keyCode == 0xF501)
            {
                console.log("Received PIP key");
            }
        }
    }

### SSL Configuration

A sample certificate file, containing a useful set of certificates, is
provided with the OpenTV WebKit. It is located by default at `/home/otv_system/ssl/certs/CAfile.pem`. This
file path is defined in the `otvwebkit-config.xml` using the <ssl-ca-file> entry, and may be modified to
point to any location. If this entry is empty all https web sites are
accessible.

Refer to the *OpenTV 5 HTML Advanced Developer’s
Guide* for details about how to modify the *otvwebkit-config.xml* file.

Any new certificates must be added to the existing certificate file; all
certificates must be PEM encoded and concatenated into this single file.

The `openssl` command line tool (refer to [https://www.openssl.org/](https://www.openssl.org/) for details) may be used to convert a certificate file, typically `.crt`, into a `.pem` file.

The following command uses openssl to create a
*CAFile.pem* from a *net.crt*:

    openssl x509 –in net.crt –outform pem –out CAFile.pem

To create one .pem file from multiple certificates:

    openssl x509 –in net1.crt –outform pem –out caf1.pem
    openssl x509 –in net2.crt –outform pem –out caf2.pem
    openssl x509 –in net3.crt –outform pem –out caf3.pem
    cat caf\*.pem > CAFile.pem

The `–outform` option ensures that the resulting
encoding is PEM, no matter what the input encoding or file extensions
may be. The final ‘cat’ command can be duplicated by any text editor as
the PEM encoding is stored as ASCII text. Note that the openssl command itself assumes there is only one
certificate in a file.

## HTML Media Elements

This section summarizes the supported HTML media tags.

### &lt;video&gt; tag

The <video> tag is a standard element
supported by HTML5 (refer to [*http://www.w3schools.com/html/html5\_video.asp*](http://www.w3schools.com/html/html5_video.asp)
for full description). It is used to display and control video content
inside HTML applications.

Starting with OTV 5.1.2, the <video> tag
is able to display videos in the standard manner without using the CCOM
Player object.

Note that the previous video tag behavior, using CCOM Player, is still
supported.

* The href/src field of the <video> tag is used to specify a real source
URL, for example: http://youtube.com/a\_video.mp4.

The xlink:href attribute value should be set
to the empty string xlink:href="".

The xlink:href="display://0" setting is
ignored.

* If the application uses a video tag along with the CCOM Player, it
must specify a video destination for the <video> tag to be paired with the CCOM player
instance. This is done by using a custom <param> attribute, called otv-video-destination. For example:

    <video id="video0" x="0" y="0" width="1280" height="720"
    xlink:href="">
        <span class="CodeBold"><param name="otv-video-destination"
        value="display://0" />
    </video>

In this example, the <video> tag
"video0" specifies the video destination "display://0", and it will be
paired with the CCOM player instance with destUri "display://0".

* If application does not use the CCOM Player for video control, it can
specify a video destination for the <video> tag to be paired with an existing CCOM
player instance whose destUri matches the
value field (“display://0”). This prevents the creation of a new player
instance which saves memory/decoder resources:

    <video id="video0" x="0" y="0" width="1280" height="720" xlink:href="http://youtube.com/myvideo.mp4">
        <param name="otv-video-destination" value="display://0" />
    </video>

In this example, the <video> tag
"video0" also specifies the valid source url, which instructs the player
instance with destUri "display://0" to play
the source url "http://youtube.com/myvideo.mp4" automatically.

* For HTML, the custom "otv-video-destination" field can be set within
the <video> tag declaration to specify a
video destination. For example:

    <video id="v1" width=1280 height=720 src="http://a.mp4"
    otv-video-destination="display://0" />

* When a video destination for the <video-> tag is not specified, no CCOM player
instance will be paired with the <video>
tag. In this case, the browser creates a unique player instance, and the
application can only use the standard W3C <video> tag methods to control the video. For
example:

    <video id="video0" x="0" y="0" width="1280" height="720"
    xlink:href="http://youtube.com/myvideo.mp4">

    </video>

#### Code Sample

The following simple code example shows the <video> tag in action.

    <body>
        <div id="DivParent">

            <video class="Video" id="video1" src="http://video.mp4" autoplay></video>

            <div id="DivSibling"> The layer floating above the video
            </div>

        </div>
    </body>

Here DivParent is the parent of the video object, and DivSibling is the sibling of the video object and is displayed above it.

### &lt;audio&gt; tag

The <audio> tag is used to control audio
content within HTML applications. The <audio> tag is a standard element supported by
HTML5; refer to [*http://www.w3.org*](http://www.w3.org/) for
full a description.

In OpenTV 5, the behavior of the <audio> is relatively
straightforward, as in the following example:

    <audio controls>

        <source src="horse.ogg" type="audio/ogg">

        <source src="horse.mp3" type="audio/mpeg">

        Your browser does not support the audio tag.

    </audio>

The specific type of audio file supported will vary from platform to
platform, however it is expected that MP3 files will be used as a
default.

## Application Installation

This section describes how to install OpenTV5 applications.

### Overview

OpenTV 5 uses W3C widget packages for application installation; the
package must be correctly structured and include a certificate/signature
in order to be valid.

### Installation Format

#### Installation Package

Applications must be installed as a valid W3C widget package, conforming
to the following specifications: [*http://www.w3.org/TR/2012/REC-widgets-20121127*](http://www.w3.org/TR/2012/REC-widgets-20121127).

A valid OpenTV package consists of a valid W3C widget package
containing:

* The configuration document, called *OTVAppMetadata.xml*.

* The application source files and assets, located at the root of the
widget package or subfolders.

* A start file, as referenced by *OTVAppMetadata.xml*

* Zero or more digital signatures located at the root of the widget
package.

#### Certificates

A certificate uses a digital signature to bind together a public key
with an identity. All application installations require certificates.

The OpenTV package uses XML digital signature, as specified at: [*http://www.w3.org/TR/2013/REC-widgets-digsig-20130418*](http://www.w3.org/TR/2013/REC-widgets-digsig-20130418).

The signature syntax and processing specification is available at:
[*http://www.w3.org/TR/2013/REC-xmldsig-core1-20130411*](http://www.w3.org/TR/2013/REC-xmldsig-core1-20130411).

A digital signature consists of:

* One Author signature file (*author-signature.xml*)

* One or more distributor signature files (*signature1.xml*)

To generate a digital signature, refer to: [*http://www.w3.org/TR/2013/REC-widgets-digsig-20130418/\#algorithm-to-generate-a-digital-signature*](http://www.w3.org/TR/2013/REC-widgets-digsig-20130418/#algorithm-to-generate-a-digital-signature)

To validate the digital signature, refer to: [*http://www.w3.org/TR/2013/REC-widgets-digsig-20130418/\#algorithm-to-validate-digital-signatures*](http://www.w3.org/TR/2013/REC-widgets-digsig-20130418/#algorithm-to-validate-digital-signatures)

To generate the digital signature use following algorithms:

* For the SignedInfo Canonicalization Method Algorithm, refer to:\
[*http://www.w3.org/2001/10/xml-exc-c14n\#*](http://www.w3.org/2001/10/xml-exc-c14n){.bullet1}

* For the SignedInfo Signature Method Algorithm, refer to:\
[*http://www.w3.org/2001/04/xmldsig-more\#rsa-sha256*](http://www.w3.org/2001/04/xmldsig-more#rsa-sha256){.bullet1}

* For the Reference Digest Method Algorithm, refer to:\
[*http://www.w3.org/2001/04/xmlenc\#sha256*](http://www.w3.org/2001/04/xmlenc#sha256){.bullet1}

* For the Property Transform Algorithm, refer to:\
[*http://www.w3.org/2006/12/xml-c14n11*](http://www.w3.org/2006/12/xml-c14n11){.bullet1}

### Signature Format

<span class="SmallCaps">**Note:** A signed package contains
digital signature files; an unsigned package does not contain digital
signature files. All developers must provide signed packages, otherwise
installation fails.

The signature file (for the author or distributor) must use the
following:

* Canonicalization Method Algorithm for SignedInfo\
Used for normalization (to remove spaces, new lines) of the
content.

* Signature Method Algorithm for SignedInfo\
Used for calculating the signature value which is kept in the
“SignatureValue” element.

* The list of non-signature file name (URI) associated with digest
method algorithm and digest value, also called hash value, calculated
over the file. The digest method algorithm is used to calculate the
digest value.

* The property reference is the same as the non-signature file reference
above, but the digest value is calculated over the property element in
the XML file (<Object Id="prop”> …
</Object>).

* A SignatureValue generated by the algorithm
associated with the SignatureMethod Algorithm.

* A list of one or more certificate in <X509Certificate>.\
One of the certificates is an end entity certificate and the others are
CA certificates. The CA certificates are used for verification of end
entity certificate. The end entity certificate contains a valid public
key.

* A Property object element.\
This specifies the signature document properties and the user-defined
properties.

<span class="SmallCaps">**Note:** in real deployment, networks or
network authorized entities will sign the application package. For
development purposes, Nagra provides a tool to package up and sign the
application.

#### Downloading and Installing the Package

After a valid installation package has been created for an application,
it must be installed onto the set-top box. This is accomplished using
Application Information Manager object (AIM) methods and events.

* Install using installApp()\
Requires a downloadURL string, which is
either a download server link, or a local zip file. This method checks
the client's credentials, downloads/copies the application package, adds
the application metadata to the application database, and sets the home
directory and permissions. If successful, it returns the new and unique
application UUID (identifying the application on the network) to the
caller via the installAppOK event.

* Installation Failed\
If the installation fails, an installAppFailed
event is generated. Failure to install is generally due to an invalid
installation package.

* Uninstall\
If an application is uninstalled after being successfully installed via
uninstallApp(), the system automatically
cleans up the application remnants, removing directories and data used
and accessed by the application. It also removes any configuration
settings defined by the application using the Configuration Manager
object methods.

* Configuration Manager\
Create entries for this application using the Configuration Manager.
Refer to [<span class="LiteralText">*Configuration Manager
Permissions*](http://otv5docs/CCOM5.1.4/Support/Application%20Developer's%20Guide.htm#Racbabbedai){.Topic}
for details.

#### Sample Installation Package

A (valid) sample installation zip file can be found in the SDK tutorials
folder, one for each of the sample applications. In addition, NAGRA
provides a tool, the Application Controller, which can be used to
automatically create and sign a new installation package from a valid
collection of files.

### Permissions and the Application Metadata File

When an application is installed, its application metadata file is
immediately read and processed, and its permissions automatically
validated by the Application Information Manager (AIM). Later, when a
running application attempts to use a component’s methods, its
permissions are checked by the component.

## Overview of OpenTV5 API (CCOM)

CCOM is the JavaScript API provided by Nagra to access the features of
OpenTV5 middleware.

This section describes the various CCOM objects and their functionality.
This is a broad and general view of the objects and their role in
application development; for a more detailed picture, refer to each
object’s specific tutorial and API documentation.

Starting with OpenTV5.1.3, the Middleware enforces a permissions scheme
restricting the features and resources an application is able to access.
This is detailed in the [<span
class="LiteralText">*Permissions*](http://otv5docs/CCOM5.1.4/Support/Application%20Developer's%20Guide.htm#Racbabbjdih){.Topic}
section.

### Object Roles

The following table gives a snapshot of CCOM objects and their roles.

**Object**

**Role**

**Canonical Methods**

Application

Facilitates communication between the application and the application
manager; generates events when an application takes an action or
messages are transmitted to an application. If an application wants to
defer going to low power mode (e.g. the user gets a "Do you want to go
to low power mode?" message) the application calls the delayLowPower
method.

*  CCOM.Application.delayLowPower\
Delays the system from going into low power mode.

AIM (AppInfoManager)

Stores and updates application metadata including signatures and client
permissions. Allows an application to run an SQL query to get an
application’s metadata. Also allows an application to be installed or
uninstalled.

* CCOM.AppinfoManager.\
getAppinfoByQuery\
Creates a SQL query which returns a given application’s metadata.

ApplicationManager

Control applications: create, get status of, communicate with, suspend,
and destroy them.

*  CCOM.ApplicationManager.launchApplication\
Create a new application and supply it with all necessary initial
state data.

*  CCOM.ApplicationManager.sendMessage\
Send a message to a specified application.

AppTimeSource

Sets the system time.

*  CCOM.AppTimeSource.setTimeData\
Sets the time obtained from a remote server.

ConditionalAccess

Controls the set-top box smartcard (changing its settings, deleting
settings, altering permissions, checking PIN codes).

*  CCOM.ConditionalAccess.changePinCode\
Changes one of the PIN codes in the smartcard.

*  CCOM.ConditionalAccess.validatePinCode\
Challenge and check one of the smartcard PIN codes.

ConfigManager

Get and/or change configuration settings (as defined in directory paths
and in encryption keys, set key paths, etc.).

*  CCOM.ConfigManager.setValue\
Sets the value of the configuration key at a specific keypath.

*  CCOM.ConfigManager.setEncryptedValue\
Encrypts and sets the value of the configuration key at a
specific keypath.

ControlCenter

Allows for clearing of the Squid cache, as well as Factory reset or
Refurbishing.

*  CCOM.ControlCenter.HttpCache.clear\
Clears the Squid cache of stored objects.

DRM

Retrieves digital rights management information.

*  CCOM.DRM.getDrmInfo\
Returns DRM information.

EPG

Query the contents of the EPG database, which contains Service and Event
metadata acquired from a broadcast network (e.g. digital video
broadcasting service information). Update the EPG database content.

*  CCOM.EPG.addEvent\
Add or update an entry in the Event table in the EPG database.

*  CCOM.EPG.getEventsRSByQuery\
Return a ResultSet used to search for events by query.

HomeNetworking

Play and control DLNA devices and services.

*  CCOM.HomeNetworking.getDevices\
Get a list of list DLNA Media Servers and DLNA Media Renderers.

*  CCOM.HomeNetworking.subscribeService\
Subscribes to one of the service types for a particular device on
the network.

Home Networking Scheduler

Schedule PVR recordings on a remote server set-top box via the UPnP
Schedule Recording Service (SRS) by creating, updating, and deleting
schedules and tasks. Note: this is not a singleton, and an instance of
the object must be manipulated, not the object itself.

\[Home Networking Scheduler
Instance\].createSchedule\
Create a schedule object which contains information about an SRS
recordSchedule.

\[Home Networking Scheduler Instance\].getSchedules\
Get the specification of one or all recordSchedules in the SRS.

IPNetwork

Search and connect to an IP Network.

*  CCOM.IpNetwork.connectToWirelessNetwork\
Connect to a specific wireless network and pass along any
required security authentication.

MediaLibrary

Control media files. Load media files, associate files with various
devices, purge media files, query for media file descriptions and
content information.

*  CCOM.MediaLibrary.loadMedium\
Scan the files in the medium, parse them, and insert metadata of
known files into the database.

*  CCOM.MediaLibrary.getEntryRSByQuery\
Retrieve content based on a criterion and return the results via
a ResultSet object.

NotifyService

Allows applications to receive Notify (custom OpenTV short messaging
system) messages and access their payload. If registered to accept
Notify messages, an application receives indication of a new message
using the onNotifyMessage event.

No methods, but an important event:

* onNotifyMessage\
Supplies a Notify message to an application with the following
properties:\
messageID\
expirationDate\
actionHandler\
actionDescription\
actionResources\
messagePayload

Player

An extremely important object, responsible for control of broadcast
streams. Using this object audio and video settings, stream details, and
error returns can be manipulated and fine-tuned. This object can also be
used to control recorded and VOD content. Note: Player is not a
singleton, and an instance of the object must be manipulated, not the
object itself.

*  \[Player Instance\].play\
Plays content after supplying the stream source and other
parameters.

*  \[Player Instance\].setPosition\
Move to a specific location in a stream (demarcated in
milliseconds).

Player Manager

Creates or releases an instance of a player object. The Player Manager
object must be used to create a Payer instance before any Player object
methods can be used/accessed. Also defines some general settings used
for stream playback, such as audio and buffer options.

*  CCOM.PlayerManager.getInstance\
Creates a player instance for the destination URI specified by
the input parameter, which is a character string containing a
destination URI that uniquely identifies the Player instance within the
whole system.

*  CCOM.PlayerManager.releaseInstance\
Releases a player object specified by the input parameter
previously retrieved by getInstance().

Pwrmgr

Gets and sets the current power mode for the set-top box. Can also force
a set-top box to reboot or wake from a sleeping state.

*  CCOM.Pwrmgr.userModeGet\
Retrieves the power mode (low power, standby power, etc.).

*  CCOM.Pwrmgr.userReboot\
Reboots the set-top box either immediately or when safe.

Scheduler

Used to control scheduling for video recording, reminders, downloads,
and other time-dependent jobs. Create a new task at a given time; delete
a task; modify a task; retrieve current tasks.

*  CCOM.Scheduler.addJob\
Creates a new scheduling job at a given time. Job can be either
one-time or ongoing.

*  CCOM.Scheduler.getJobsRSByQuery\
Retrieves services based on criteria and returning the results
via a ResultSet.

SINetwork

Defines scan and scan configuration settings. Scan for a transponder;
get the connection information from a tuner; etc.

*  CCOM.SINetwork.scan\
Begin a scan; find transponders and retrieve SI information for
building a service list and EPG.

*  CCOM.SINetwork.getConnectionInfo\
Retrieve signal quality information for a tuner connection
already in progress.

SoftwareUpgradeManager

Request, cancel, and otherwise control system upgrades.

*  CCOM.SoftwareUpgradeManager.getUpgradeStatus\
Returns the status of the current upgrade.

*  CCOM.SoftwareUpgradeManager.requestUpgrade\
Request or cancel upgrades.

System

Modify and control the system: reboot the system, reset the system, set
configuration settings, control the set-top box front panel, etc.

*  CCOM.System.reboot\
Perform a hard reboot.

*  CCOM.System.applyConfigSettings\
Apply various configuration settings to DVM modules specified in
the method input.

UserAuth

Control security and modify/add authorization settings for restricted
channels. Modify a login PIN or password, and authorize/verify a given
PIN.

*  CCOM.UserAuth.addRestrictedChannel\
Add a restricted channel to allowable viewable channels if the
supplied PIN or password passes a security check.

*  CCOM.UserAuth.enableSystem\
Enable the user authentication system, and check to see whether
the master PIN exists; if not, create a master PIN with the default
value.

WindowManager

Control and modify the window manager.

*  CCOM.WindowManager.registerInputEvents\
Register for notification of an input event signal. A call to
this method causes Windows Manager to send an inputEventOccurred signal
exclusively to the application associated with the specified service.

### How to invoke CCOM APIs

The main CCOM object contains properties which are also objects, each
providing access to a sub-set of middleware functionality.

For example, the CCOM.EPG object provides EPG
functionality, while the CCOM.SINetwork
provides channel scan functionality.

To access OTV 5 middleware functionality, application developers must
use a JavaScript interface and a JavaScript binding layer to communicate
with CCOM objects. CCOM uses the Netscape Plug-in Application
Programming Interface (NPAPI) framework and must be loaded by the
application through the corresponding HTML tag: <embed>.

Refer to the W3C web site ([*http://www.w3.org*](http://www.w3.org/))for
further details.

In order to use a CCOM object, an application must first use the
JavaScript method document.getElementById() to
access the main, or root, CCOM object.

The following section summarizes how the getElementById() method is used to access the main
CCOM object in OpenTV 5.

#### CCOM API invocation Example:

The following example illustrates how the method
document.getElementById() is used to access
the CCOM Configuration Manager object.

    <embed id="CCOMid" type="application/CCOM\_HTML" width="0"
    height="0"> </embed>

    <script>
        var CCOM = document.getElementById("CCOMid");
        var configMan = CCOM.ConfigManager;
    </script>

## Application Permissions

This section describes the OpenTV5 application permission system.

### Overview

Starting with OpenTV 5.1.3, a permissions-based application security
mechanism has been put into place, guaranteeing that applications can
only access authorized system operations, features, or resources.

Permissions are defined as authorizations (rights or privileges) granted
to an application, allowing access to specific system resources in
specific ways.

There are two general categories of permissions: those authorizing the
use of CCOM-based services (service permissions), and those authorizing
the use of system resources (resource permissions).

Service permissions allow access to various CCOM services, such as
methods or inter-object communication, while resource permissions allow
access to non-CCOM resources such as storage space, memory resources, or
devices (camera, keyboard, sensor).

An application accesses a CCOM service by connecting to the component
providing the service and invoking methods provided by the component;
service permissions are automatically enforced by the component
providing the service.

An application accesses non-CCOM resources (such as a networking
facility, dynamic memory, local file storage, external media, etc.) via
system capabilities depending on the resource; resource permissions are
configured when the application is launched.

In neither case is a developer required to do additional coding in order
to “enforce” permissions (after the permissions are initially defined).

The application’s metadata file contains all the service and resource
permissions authorized for the application, which are explained in
detail in the following.

### Permissions and the Application Metadata File

When an application is installed, its application metadata file is
immediately read and processed, and its permissions automatically
validated by the Application Information Manager (AIM). Later, when a
running application attempts to use a component’s methods, its
permissions are checked by the component.

#### Service Permissions

Service permissions are separated into two major categories:

* Permission based on a CCOM API:\
Each permission authorizes the use of a specific API of the component.

* Permission based on groups of related CCOM APIs:\
Each permission authorizes the use of a specific group of APIs; or, they
may be based on the features that the component implements via its APIs,
where each permission enables or constrains the use of the component's
APIs in a specific manner.

Each CCOM service is identified by a globally unique service name, and
each service permission is identified by a unique service permission
string within the component providing the service.

These service names and service permission strings, in combination,
identify the services and operations authorized for the application in
the application metadata file.

Service permissions are explicitly defined in the application's metadata
file, as in this example:

\[...previous material deleted...\]

    <otv:AUTHORIZATIONS>
        <otv:SERVICES>
            <otv:AppinfoManager>
                <otv:PERMISSIONS>MANAGE</otv:PERMISSIONS>
            </otv:AppinfoManager>
            <otv:ApplicationManager>
                <otv:PERMISSIONS>QUERY</otv:PERMISSIONS>
            </otv:ApplicationManager>
                \[... other CCOM Objects...\]
        </otv:SERVICES>
    </otv:AUTHORIZATIONS>

\[...material following deleted...\]

The general format of service permissions is:

<otv:AUTHORIZATIONS>

<otv:SERVICES>

    <span class="CodeBold">**<**<span
class="CodeBold">**otv:CCOM\_Object\_Name>**

        <otv:PERMISSIONS> {one or more Permission\_Strings}

        </otv:PERMISSIONS>

    <span class="CodeBold">**<**<span
class="CodeBold">**/otv:CCOM\_Object\_Name>**

</otv:SERVICES>

</otv:AUTHORIZATIONS>

Where CCOM\_Object\_Name is the name of the
CCOM object having permissions defined, one of the following:

AppinfoManager

Application

ApplicationManager

ConditionalAccess

ConfigManager

ControlCenter

DRM

EPG

HomeNetworking

HomeNetworkingScheduler

IpNetwork

MediaLibrary

PlayerManager

Scheduler

SINetwork

SoftwareUpgradeManager

System

UserAuth

WindowManager

Refer to the following section for valid permission strings.

### CCOM Permission Strings

CCOM service permissions are specified for each object. An application
can have full, partial, or multiple CCOM object service permissions.

These permissions are listed in the API documentation for each method.

<span class="SmallCaps">**Note:** if an object method is not
listed as needing a specific permission, it does not require a
permission in order to be accessed. For example, getConnectionInfo() (part of the SINetwork CCOM
object), requires no permission to use.\
\
The only exception is deprecated methods; all deprecated methods require
ADMIN permission, even if not explicitly stated elsewhere.

<span class="SmallCaps">**Additional Note**: the global methods
addEventListener() and removeEventListener(), available to all CCOM
objects, do not require permissions in order to be used.

The following table lists the valid permission strings. Note that not
all permission strings are valid/useful for all CCOM Objects.

+--------------------------+--------------------------+--------------------------+
| **Permission String**    | **Type**                 | **Definition**           |
+--------------------------+--------------------------+--------------------------+
| QUERY                    | Generic                  | Allows read-only access  |
|                          |                          | to existing data, with   |
|                          |                          | no side effects. Reading |
|                          |                          | sensitive data may       |
|                          |                          | require higher rights    |
|                          |                          | (such as MANAGE).        |
+--------------------------+--------------------------+--------------------------+
| CONTROL                  | Generic                  | Allows for operating on  |
|                          |                          | existing objects, e.g.   |
|                          |                          | in order to play or      |
|                          |                          | connect to a data        |
|                          |                          | source.                  |
|                          |                          |                          |
|                          |                          | CONTROL implies QUERY.   |
|                          |                          | CONTROL allows also      |
|                          |                          | inter-application        |
|                          |                          | messaging.               |
+--------------------------+--------------------------+--------------------------+
| MANAGE                   | Generic                  | Allows deleting,         |
|                          |                          | updating, creating,      |
|                          |                          | saving data or objects,  |
|                          |                          | changing their state,    |
|                          |                          | etc.                     |
|                          |                          |                          |
|                          |                          | MANAGE implies CONTROL   |
+--------------------------+--------------------------+--------------------------+
| ADMIN                    | Generic                  | The same as MANAGE but   |
|                          |                          | also includes global     |
|                          |                          | effects on the set-top   |
|                          |                          | box state which could    |
|                          |                          | can be harmful, e.g. set |
|                          |                          | time, install            |
|                          |                          | applications, perform a  |
|                          |                          | factory reset, etc.      |
|                          |                          |                          |
|                          |                          | ADMIN implies MANAGE\    |
|                          |                          | \                        |
|                          |                          | NOTE: All deprecated     |
|                          |                          | methods require the      |
|                          |                          | ADMIN permission.        |
+--------------------------+--------------------------+--------------------------+
| Profile\_1 to Profile\_8 | Specific                 | Defines configuration    |
|                          |                          | tree access. Only used   |
|                          |                          | with ConfigManager.      |
+--------------------------+--------------------------+--------------------------+
| ENCRYPT                  | Specific                 | Allow access to          |
|                          |                          | encrypted configuration  |
|                          |                          | tree settings. Only used |
|                          |                          | with ConfigManager.      |
+--------------------------+--------------------------+--------------------------+

An outline of the various configuration setting locations and their
interactions follows:

**Path or File**

**Description**

**Notes**

\[application installation folder\]/OTVAppMetadata.xml

The path and name of the application configuration file for the
application having permissions defined.

This file contains all the permissions defined for the application, and
references one or more network access profiles used by the configuration
manager, and might further restrict the permission paths defined by
them.

/system/opentv/configman/profiles

Location of access profiles on the network, used to define configuration
manager permissions.

Defines the default paths accessible by PROFILE\_1 to PROFILE\_8\
\
Paths defined in these files should include paths required by
applications referencing them; applications cannot define paths not
already contained within one or more of these files.

/system/opentv/otvsec/memory-resource-mapping

Defines the maximum memory values

String values are either SMALL, MEDIUM, or LARGE, and referenced by the
application configuration file. The actual memory size values are
defined by integer at the network configuration location.

/applications/AUTHOR\_Name/App\_ID

Defines the network location for the application’s specific folder.

Heavy restrictions exist for the characters allowed in these path
components; refer to the [Application-specific
Directory
Structure](http://otv5docs/CCOM5.1.4/Support/Application%20Developer's%20Guide.htm#Racbabgfibc)
for details. Must match values defined in the application configuration
file.

### Configuration Manager Permissions

The Configuration Manager object does not operate like other objects.

Instead of defining permissions for how Configuration Manager interacts
with other objects, this set of permissions defines how Configuration
Manager interacts with and reads/modifies the configuration tree.

Permissions are not defined on a method-by-method basis. Permissions
apply to all methods in the Configuration Manager object equally and
uniformly.

There are nine permission strings used with this object:

*  ENCRYPT\
Allows an application access to selected encrypted parts of the
configuration tree.

*  PROFILE\_1, PROFILE\_2, PROFILE\_3, PROFILE\_4,
PROFILE\_5, PROFILE6, PROFILE\_7, PROFILE\_8\
Eight profiles that control the amount of access the application
has to the configuration tree. These profiles are defined on a
network-by-network basis.

#### Application-specific Directory Structure

Application-specific configuration settings are stored in specific
directories within the /applications subtree,
subject to the following restrictions:

* An application producer has a producer-specific configuration
directory under /applications, the name of
which matches the value of the AUTHOR element
in the application metadata file. For example, a producer with the AUTHOR value of jimmy-X must have a
producer-specific directory at /applications/jimmy-X.

* Each application from the same producer has an application-specific
configuration directory under the producer-specific configuration
directory of its producer, the name of which matches the value of the
APP\_ID element in the application metadata
file. For example, an application with APP\_ID
values of application-Y and application-Z, both from producer jimmy-X,
each must have an application-specific configuration directory at /applications/jimmy-X/application-Y and /applications/jimmy-X/application-Z, respectively.

* Naming restrictions:\
The AUTHOR and APP\_ID values must not contain any of the following
characters: \\/ \\\\ \\t \\r \\n ” \$ & < > , +
= \# ! ( ) ‘ | \[ \] ? \~ \` ; \*. Due to these naming
restrictions, Configuration Manager replaces any non-conforming
characters from the AUTHOR or APP\_ID values from the application metadata with an
underscore ('\_') when forming the producer- or application-specific
directory name.

* In a sandboxed runtime environment, an application accesses a
configuration setting within its application-specific directory by using
a relative path from the root of its application-specific directory. For
example, if application-Y from producer-X needs to access a setting
named my-key-Y in the subdirectory my-subdir-Y within its
application-specific directory, it would use the relative keypath of
my-subdir-Y/my-key-Y (or, optionally, ./my-subdir-Y/my-key-Y), which would access the
setting found at the absolute path /applications/producer-X/application-Y/my-subdir-Y/my-key-Y.

* In a non-sandboxed runtime environment, an application accesses a
configuration setting within its application-specific directory by using
an absolute path from the root of the configuration tree, e.g.: /applications/producer-X/application-Y/my-key-Y.

* In a sandboxed runtime environment, an application accesses a
configuration setting within its producer-specific directory by using a
relative path of .. (two consecutive dots) that refers to its
producer-specific directory. For example, if application-Y from
producer-X needs to access a setting named my-producer-key-Y in its
producer-specific directory, it would use the relative path of ../my-producer-key-Y, which would access the
setting found at the absolute path /applications/producer-X/my-producer-key-Y.

* In a non-sandboxed runtime environment, an application accesses a
configuration setting within its producer-specific directory by using an
absolute path from the root of the configuration tree, e.g.: /applications/producer-X/my-producer-key-Y.

To ensure an application runs properly in either a sandboxed or
non-sandboxed runtime environment, applications should be written to
access configuration settings using absolute path names only.

New applications should be designed to use application-specific and
producer-specific directories for settings.

Be aware that an application-specification configuration directory of an
application is removed when the application is uninstalled.

Note: For more details about how the configuration tree is structured,
refer to the *Configuration Guide*.

#### Access Profiles

Application access to configuration settings is limited by default as
follows:

*  read-write access to settings in its own
application-specific configuration directory, and

*  read-only access to settings in its
producer-specific configuration directory.

To access a configuration setting elsewhere in the configuration tree,
even the application-specific directory of another application from the
same producer, the application *must have
explicit permission* to access the directory containing the
setting.

This permission is specified by an access profile in the application’s
metadata file, as well as the allowable paths defined in /system/opentv/configman/profiles.

Eight possible access profiles, PROFILE\_1 to
PROFILE\_8, control this access. An access
profile consists of a list of one or more access permissions, including
an access mode (read-only, read-write, or no-access), and a
configuration pathname for the configuration subtree covered by the
profile.

An application with a particular access profile is allowed to access
configuration settings via the absolute pathname in the profile and the
specified access mode in the profile, in addition to the configuration
settings in its application-specific directory and producer-specific
directory. The access profile definitions are stored as string lists
named profile-1 to profile-8 in the /system/opentv/configman/profiles configuration
subtree.

At present, there are placeholders (empty lists) for profile-1 to profile-7
under /system/opentv/configman/profiles. There
is a defined profile-8 in the Configuration
Manager default xml file as well; this profile, defined to permit
read-write access to the entire configuration tree, is currently
required by various built-in EPG applications (e.g., Gravity, etc.),
which need to access configuration settings throughout the configuration
tree. The metadata for these applications has been modified to include
PROFILE\_8 permission. Without this profile,
these applications fail at launch.

A system default profile can be found at /system/opentv/configman/profiles/system. This
profile defines read-only access to the /system/opentv/rtes and /system/opentv/services subtrees, which is needed to
run any application.

An additional network default profile is defined at /system/opentv/configman/profiles/network, although
as currently defined it is an empty list, and it may be used to define a
network-specific profile that is needed to run any application.

**Changing the Profile Definitions**

Default profile paths are defined in /system/opentv/configman/profiles.

Three definitions are allowed when defining profiles:

*  readwrite\
Allows for read-write access to the associated directory and any
directory below it.

*  readonly\
Allows read-only access to the associated directory and any
directory below it.

*  noaccess\
Neither read nor write access is granted to the associated
directory nor any directory below it.

For example, suppose PROFILE\_1 is needed to
allow an application to access the settings in the following subtrees:

* read-write access to /users/preferences

* read-only access to /applications/common

* read-only access to /users/default

The access profile is defined as a string list in the metadata file with
the access permissions:

*  readwrite:/users/preferences

*  readonly:/applications/common

*  readonly:/users/default

If an application has PROFILE\_1 specified in
its metadata file, the application is allowed to read or write settings
in or below /users/preferences and read
settings in or below /applications/common and
/users/default.

If PROFILE\_2 is required to allow an
application from producer-X to read or write the settings of
application-Y, also from the same producer, i.e., to read or write
settings in or below /applications/<producer-X>/<application-Y>,
the access profile is defined as a string list at /system/opentv/configman/profiles/profile-2
containing the access permission:

readwrite:../<application-Y>

Then, if an application from producer-X, say application-Z, has the
profile\_2 permission specified in its
metadata file, the application is allowed to read or write settings in
or below /applications/<producer-X>/<application-Y>.

Any application from producer-X with the PROFILE\_3 permission specified in its metadata is
allowed to read the settings of any other application from producer-X.
Since an application is always allowed to read or write its own settings
and to read the settings of its producer, the access permissions readwrite:. and readonly:.. are implied and don’t need to be
explicitly specified.

To prevent access to part of a subtree even though other parts of the
subtree are accessible, noaccess is used. For
example, suppose that PROFILE\_4 should allow
read-only access to the /users/preferences
subtree but not allow access (neither read-only nor read-write)
to the /users/preferences/parental-rating
setting. In this case, the access profile /system/opentv/configman/profiles/profile-4 is
defined as a string list containing the access permissions:

*  readonly:/users/preferences

*  noaccess:/users/preferences/parental-rating

An application may specify more than one access profile in its metadata.
In general, the order of the profiles specified in the application's
metadata is not significant, nor is the order of access permissions
within an access profile. However, if the same configuration pathname is
specified more than once for the same application (because the pathname
appears in more than one profile specified by the application or because
the pathname appears more than once in the same profile), then the last
sequential appearance of the pathname and the associated access mode
replaces any previous appearance of the pathname and associated access
mode.

**Sample Profile Definition**

Partial file example, located in /system/opentv/configman/profiles.

<dir name="configman">

    <dir name="profiles">

    <!-- profiles that are specified in app metadata -->

    ...

    <entry name="profile-3" type="list" ltype="string">

    </entry>

    <entry name="profile-4" type="list" ltype="string">

    </entry>

    <entry name="profile-5" type="list" ltype="string">

    </entry>

    <entry name="profile-6" type="list" ltype="string">

    </entry>

    <entry name="profile-7" type="list" ltype="string">

    </entry>

    <entry name="profile-8" type="list" ltype="string">

    <!-- profile for builtin EPG apps -->

        <li type="string">

        <stringvalue>readwrite:/</stringvalue>

        </li>

    </entry>

    </dir>

</dir>

[]()**Encrypt**

Application access to encrypted configuration settings is allowed only
if the application’s metadata file specifies the ENCRYPT permission. In
the absence of an access profile in the application’s metadata, an
application with ENCRYPT permission is allowed read-write access to
encrypted settings in its application-specific directory and read-only
access to encrypted settings in its producer-specific directory.

If an application with ENCRYPT permission also has one or more access
profile permissions, the application is allowed to access encrypted
settings in the subtrees specified by the corresponding access
profile(s) as constrained by the corresponding access mode.

### Resource Permissions

Resource permissions are defined in the application metadata file, with
some definitions for memory maximums also found at /system/opentv/otvsec/memory-resource-mapping.

The following system resources are currently supported:

* Network access:\
The <otv:NETWORK> resource permission
element allows the application to use network interfaces.

* RAM usage:\
The <otv:MEMORY> resource permission
element specifies how much RAM the application is allowed to use. The
text content of the element is either SMALL,
MEDIUM, or LARGE.
The corresponding memory size values are defined by integer
configuration settings under /system/opentv/otvsec/memory-resource-mapping in the
default configuration tree.

* Local storage:\
The <otv:STORAGE> resource permission
element allows the application to use local persistent storage.
Currently, only the presence of this permission is required to allow
local storage usage, without constraint on how much is used. Presence of
string values SMALL, MEDIUM, or LARGE has no effect.

* Key stealing:\
The <otv:KEYS> resource permission
element defined the list of keys that the application is allowed to
steal when it is not in-focus. The text content of the element is a list
of logical key names may include any of the following: DOM\_VK\_ENTER, DOM\_VK\_DELETE, DOM\_VK\_LEFT,
DOM\_VK\_RIGHT, DOM\_VK\_UP, DOM\_VK\_DOWN, DOM\_VK\_PAGE\_UP,
DOM\_VK\_PAGE\_DOWN, OTV\_RED, OTV\_BLUE, OTV\_YELLOW, OTV\_GREEN,
OTV\_0, OTV\_1, OTV\_2, OTV\_3, OTV\_4, OTV\_5, OTV\_6, OTV\_7, OTV\_8,
OTV\_9, OTV\_F6, and OTV\_F7.

An example from an application configuration file follows, in which
network access is permitted, local storage is permitted, four keys are
active, and the memory permission is MEDIUM:

...

<otv:RESOURCES>

    <otv:NETWORK/>

    <otv:STORAGE>SMALL</otv:STORAGE>

    <otv:KEYS>OTV\_YELLOW OTV\_BLUE OTV\_F6
OTV\_F7</otv:KEYS>

    <otv:MEMORY>MEDIUM</otv:MEMORY>

</otv:RESOURCES>

...

### Sample Permission-enabled Application Metadata File

A sample file follows, defining an application with five CCOM objects
permissions, as well as the following resource permissions: network,
memory, local storage, and four keys.

<?xml version="1.0" encoding="UTF-8"?>

<AIM>

<NAME>app\_portal\_test</NAME>

<AUTHOR>OPENTV</AUTHOR>

<AUTHOR\_HREF>http://www.nagra.com/dtv/</AUTHOR\_HREF>

<AUTHOR\_EMAIL>gqyu@opentv.com</AUTHOR\_EMAIL>

<APP\_ID>app\_portal\_test\_id</APP\_ID>

<APP\_TYPE>svg</APP\_TYPE>

<APP\_VER>3.4</APP\_VER>

<START\_ARG>portal.svg</START\_ARG>

<span class="CodeBold">**<otv:AUTHORIZATIONS**<span
class="CodeBold">**><**<span
class="CodeBold">**otv:SERVICES**<span
class="CodeBold">**>**

    <otv:AppinfoManager>

        <otv:PERMISSIONS>MANAGE</otv:PERMISSIONS>

    </otv:AppinfoManager>

    <otv:ApplicationManager>

        <otv:PERMISSIONS></otv:PERMISSIONS>

    </otv:ApplicationManager>

    <otv:Application>

        <otv:PERMISSIONS>ADMIN</otv:PERMISSIONS>

    </otv:Application>

    <otv:System>

        <otv:PERMISSIONS>ADMIN</otv:PERMISSIONS>

    </otv:System>

    <otv:IpNetwork>

        <otv:PERMISSIONS>ADMIN</otv:PERMISSIONS>

    </otv:IpNetwork>

    <otv:ConfigManager>

        <otv:PERMISSIONS>PROFILE\_8
ENCRYPT</otv:PERMISSIONS>

    </otv:ConfigManager>

</otv:SERVICES>

<otv:RESOURCES>

    <otv:NETWORK/>

    <otv:STORAGE>SMALL</otv:STORAGE>

    <otv:KEYS>OTV\_YELLOW OTV\_BLUE OTV\_F6
OTV\_F7</otv:KEYS>

    <otv:MEMORY>MEDIUM</otv:MEMORY>

/otv:RESOURCES>

**</otv:AUTHORIZATIONS>**

</AIM>

## Digital Storage Media Command and Control (DSMCC)

### Overview

This section describes how an application can register for and receive
digital storage media command and control (DSMCC) stream event
information.

OpenTV 5.1.4 will run HTML5 applications configured as AUTOSTART by an application information table (AIT)
and transported by a DSMCC object carousel, where both the carousel and
the AIT are available in the currently-tuned transport stream. It is
expected that the carousel has been mounted to the OpenTV5 middleware
and that the application’s constituent files are accessible as though
they were local. This capability is wanted particularly by networks
without IP accessibility.

Such an application may also listen for and respond to DSMCC stream
events, so, for example, the applications can know when to change the UI
it’s presenting.

Also, applications may want to use files that reside in a DSMCC object
carousel different from the carousel they were acquired from.

### Requesting Individual Objects from a Carousel

A file in a mounted DSMCC object carousel may be referenced by an HTML5
web page acquired from the same carousel by referring to the file using
its relative path. For example, a CSS file or an image file may be
referred to by a pathname relative to the directory from which the start
page is acquired. No file handling CCOM API is needed in this case,
since the browser is running the application directly from an object
carousel that has been mounted. Hence, the file appears as though it
were local. The application and its files are isolated adequately
because the same container rules are applied to the mounted carousel.

The following describes the API to use for acquiring a text or XML file
from a carousel.

### Requesting Individual Objects from a Carousel

In order to have access to the content of a carousel file, the XMLHttpRequest object can be used with the following
constraints:

* Parameters passed to the open() method

* **method**: Set to “GET”

* **url**: Can be relative to the location of the current page in the
carousel’s file system, or an absolute dvb:URL

* **async**: Set to true

* **user**: Ignore

* **password**: Ignore

* *status* is a property that becomes visible on the same XMLHttpRequest object once a response has been
received from the server

The caller must first register a listener for *readyStateChange* events
on the XMLHttpRequest object, then call the
method send() to send the request to the
server. The *readyState* property is set to DONE (4) once a response
has been received. It is only at that time that *status* and
*statusText* can be read (you can set the *onreadyStateChange* property
directly on the XMLHttpRequest object to
attach an event listener on that object).

It is also at that point that the *responseText* and *responseXML*
properties are valid.

*status* is set to 200 when the DSMCC object is found and to 404 when it
is not present in the carousel or the corresponding carousel has been
unmounted.

* *statusText* is a property that becomes visible on the same
`XMLHttpRequest` object once a response has been received from the
server. It is set to `OK` if status is `200` or `Not Found` if the
status is `404`.

* Headers are not relevant for carousel access:

* Calls to `setRequestHeader()` are ignored

* `getResponseHeader()` returns null and `getAllResponseHeaders()`
returns an empty string

* Values of the *responseText* and *responseXML* properties are shown in
the table below:

  DSMCC object   URL example                  responseText                                                                                                                                                     responseXML
  -------------- ---------------------------- ---------------------------------------------------------------------------------------------------------------------------------------------------------------- -------------------------------------------------------------------------------------------------------------------------------------
  File           `/weather/data.xml`          Returns the "text response entity body" as defined in `XMLHTTPRequest`.                                                                                          If the file has the extension .xml, returns the "XML response entity body" as defined in `XMLHTTPRequest`. Otherwise, returns null.
  Directory      `/weather`                   Comma-separated list of names (filename, stream event name, or directory name) of all objects in the directory. These names will not include path information.   null
  Stream event   `/weather/main/streamEvt1`   Comma-separated list of names of all events in the stream-event object                                                                                           null

Examples of dvb:URLs that may be used with the XMLHttpRequest object
are:

* `/weather/data.xml` (absolute path from the root of the carousel of
the current page)

* `../weather/data.xml` (relative path to the current page)

* `dvb://1..1.B8/weather/data.xml` (`0xB8` is the component tag)

### Usage Model for Subscribing to a Stream Event

Add a listener for a specified DSMCC stream event.

When a broadcaster transmits an identical instance of an MPEG
private-data section carrying a stream-event descriptor (including the
version number), only one *StreamEvent* event is dispatched.

When a broadcaster transmits different events using the same event name
ID (i.e. with different version numbers), one *StreamEvent* event is
dispatched for each different stream-event descriptor received.

Listeners are automatically unregistered on successful channel change.

    <script>
    ListenerForObjFile = function(e)
    {
        // check for events that are for my object
        if(e.event == “eventA”) {
            // call some handler for event A
        }
        else if(e.event == “eventB”) {
            // call some handler for event B
        }
        else if(e.event == “eventC”) {
            // call some handler for event C
        }
        else if(e.event == “eventD”) {
            // call some handler for event D
        }
    }

    CCOM.Dsmcc.addEventListener(onStreamEventReceived, ListenerForObjFile);
    
    CCOM.Dsmcc.subscribeToStreamEvent("dvb://1.2.3.B8/strmfile1", "eventA");
    CCOM.Dsmcc.subscribeToStreamEvent("dvb://1.2.3.B8/strmfile1", "eventB");
    CCOM.Dsmcc.subscribeToStreamEvent("dvb://1.2.3.B8/strmfile2", "eventC");
    CCOM.Dsmcc.subscribeToStreamEvent("dvb://1.2.3.B8/strmfile2", "eventD");
    
    </script>

### Unsubscribe from a Stream Event

When a listener for a specified DSMCC stream event is no longer wanted,
you can unsubscribe from notice of that stream event:

    CCOM.Dsmcc.unsubscribeFromStreamEvent(<stream-event-obj-file1>, "eventA")

The `<stream-event-obj-file1>` specifies the URL of the DSMCC
`StreamEvent` object. This may be, for example:

    targetUri = "dvb://" + originalNetworkId + "." + transportStreamId + '.' + serviceId + "." + componentTag + "/dir1/dir2/strmfile1"

`eventA` specifies the name of the event whose subscription should be
removed.

## Multiple Application Support

### Overview

As of 5.1.3, more than one application can be run concurrently, limited
only by resource availability (memory, CPU, etc.).

Application installation and control primarily use two CCOM objects: the
Application Information Manager (AIM), and the Application Manager
(AppMan).

### Application Information Manager

The Application Information Manager (AIM) object is responsible for
storing information about applications available on the system, as well
as applications capable of being downloaded in the future. This
information consists of the application name, metadata, and other
details.

Using AIM object methods, developers are able to download and install
applications, uninstall them, update them, and enforce credentials.
Applications are packaged as W3C widgets and installed using installApp(), which checks
certificates, permissions, and does other necessary bookkeeping before
installing the application.

### Application Manager

Once an application has been installed, the Application Manager (AppMan)
object methods can be used by developers to control applications by:

* Starting, Stopping, and Querying applications about their status, in
addition to launching an application, giving it focus (making it display
on top of any other application).

* Transmitting messages between applications.

* Creating notifications about application changes, such as application
launched, application destroyed, etc.

Key stealing is accomplished using the Windows Manager.

### Manipulating Applications

In general, Application Manager object methods are responsible for
controlling applications. These methods allow an application to:

* Launch an application.

* Destroy a running application.

* Query an application’s status, or list the currently running
applications.

* Send messages to another applications.

The Windows Manager object methods allows an application to “steal” keys
(receiving input from the keyboard via events), however there are
limitations to this:

* Key stealing is only allowed for keys defined in the `<resource>` section of the application metadata file. In this example, the `OTV_YELLOW OTV_BLUE` keys are defined, and therefore may be captured:

    <otv:RESOURCES>
        <otv:NETWORK/>
        <otv:STORAGE>SMALL</otv:STORAGE>
        <otv:KEYS>OTV_YELLOW OTV_BLUE</otv:KEYS>
        <otv:MEMORY>MEDIUM</otv:MEMORY>
    </otv:RESOURCES>

* Keys are not automatically captured when the application starts; use
the Windows Manager `registerInputEvents()` method and set the `winmanInputEventTypes` to define the capture keys.

The following MultiApp issues should also be kept in mind:

* Applications are, in general, “persistent” meaning that applications
re-launch automatically should they stop unexpectedly (due to a reboot,
for example).

* The only way to transmit information between applications is via CCOM.ApplicationManager.sendMessage().

* Application resource usage and application permissions are defined by
the application metadata file and checked/implemented during
installation. Care should be taken not overload the system by running
too many applications, whose additive demands upon CPU and other
resources might cause slowdowns.

### Manipulate Multiple Applications, Step-by-Step

What follows is a rough outline of how to manipulate multiple
applications using Application Manager and Windows Manager methods.

1. Let’s assume three applications, App1, App2, and Switcher have been successfully installed on the network via the Application Information Manager’s installApp() method.
Switcher is a master application, already launched, which sits in the background and controls the other two applications.

2. The two applications (App1 and App2)have been assigned global UUID numbers by appInstall(), which uniquely distinguishes them.

3. The Switcher application, already running, launches these two applications using launchApplication(), which requires the UUID values of the two applications. Listen for the launchApplicationOK event, and if two events are
generated (one for each application), both applications should be running.

4. To double-check they are running, call isApplicationRunning() and listen for the isApplicationRunningOK event. If two events are returned, it serves as confirmation that App1 and App2 are both running.

5. When an application has focus, it captures all keys except those
stolen by other applications. In order to set an application to capture
keys, use the Windows Manager object and the registerInputEvents() method, which allows any application to “steal” keys from input events. As always, the only keys an application is allowed to capture are those defined in its
application metadata file. Switcher has been configured to steal keys from both App1 and App2 when they are running.

6. When Switcher steals a remote control key press, indicating that the user wants App1 to close, Switcher uses CCOM.ApplicationManager.destroyApplication() to close App1. Switcher again has focus since it is the only currently-running application.

7. Should the user wish to run App2, he presses the appropriate button. Switcher receives the input and uses launchApplication()to launch App2, which when it starts will have focus over Switcher.

In general, when multiple applications are run concurrently, one
application serves as the main “switcher,” determining which
applications will be shut down or started, and therefore which
application currently has focus.

## Application Metadata File

### Overview

The application metadata file (*OTVAppMetadata.xml*) is required in order to
install, configure, and define applications. It is part of an
application installation package, and when installed it is located in
the base application folder.

A typical example follows:

    <?xml version='1.0' encoding='UTF-8'?>
    <AIM>
        <AUTHOR>NAGRA</AUTHOR>
        <NAME>CCOMTutorial</NAME>
        <AUTHOR_HREF>http://www.nagra.com/dtv/</AUTHOR_HREF>
        <AUTHOR_EMAIL>contact@opentv.com</AUTHOR_EMAIL>
        <RUNTIME_PRIORITY>0</RUNTIME_PRIORITY>
        <APP_ID>CCOMTutorial1</APP_ID>
        <APP_TYPE>svg</APP_TYPE>
        <APP_VER>1_0</APP_VER>
        <START_ARG>launch-html.svg</START_ARG>
        <otv:AUTHORIZATIONS>
            <otv:SERVICES>
                <otv:AppinfoManager>
                    <otv:PERMISSIONS>MANAGE</otv:PERMISSIONS>
                </otv:AppinfoManager>
                <otv:ApplicationManager>
                    <otv:PERMISSIONS>QUERY</otv:PERMISSIONS>
                </otv:ApplicationManager>
            </otv:SERVICES>
        </otv:AUTHORIZATIONS>
    </AIM>

A complete list of fields and options for this file are defined in the
following section.­

### Application Metadata File Structure

In general, the application metadata file should have only one entry for
each field; when there are duplicate entries, the first is ignored.

Queryable fields are those which can be accessed via: CCOM.AppinfoManager.getAppinfoByQuery().

**Name**

**Type**

**Description**

**Required?**

**Queryable?**

APP\_ID

STRING

The application ID. It must be unique for the AUTHOR. It should remain
constant in order to update the application in the future.

Yes

Yes

APP\_TYPE

STRING

The application type. The supported application types are:

* "html"\
An HTML/JavaScript application. Run via otvwebkit.

* "svg"\
An SVG application. Run via Ekioh.

* "native"\
A native application, run using the native environment.

Yes

Yes

APP\_VER

STRING

The version of the application. AUTHOR can decide the format of the
version string.

Yes

Yes

APPLICATION\_CLASS

STRING

The application class must be SYSTEM. Optional (if absent indicates a
non-system application).  Applications in the SYSTEM class are the
applications necessary for the set-top box to function, such as the main
UI.

No

Yes

AUTHOR

STRING

The AUTHOR represents person or organization creating the application.

Yes

Yes

AUTHOR\_EMAIL

STRING

The AUTHOR’s email address.

Yes

Yes

CCOM\_MINOR\_VERSION

NUMBER

The minor version of CCOM that this application is compatible with.
Optional.

No

Yes

CCOM\_MAJOR\_VERSION

NUMBER

The version of CCOM that this application is compatible with. Mandatory

Yes

Yes

AUTHOR\_HREF

STRING

The AUTHOR's URL, pointing to its web site or profile on a social
network.

Yes

Yes

DIAL\_ENABLED

BOOLEAN

This field is required for the applications that support DIAL. It is, by
default, disabled.

No

Yes

LAUNCH\_MODE

STRING

The launch mode of the application, either *FOCUSED* or *SUSPEND*.
 Default is *FOCUSED*.

No

Yes

LICENSE

STRING

Describes the software license of the application. It can be a usage
agreement, redistribution statement, or copyright license under which
the application is provided.

No

Yes

NAME

STRING

Name of the application. An optional <SHORT\_NAME> sub-element is
also supported, defining a truncated name for the application. For
example:\
\
<NAME>Poker Millions Online Tournament\
  <SHORT\_NAME>Poker</SHORT\_NAME>\
</NAME>

Yes

Yes

NOTIFY\_ON\_LOW\_POWER

STRING

This field indicates if the application supports handling the
*requestActionSignal* for the REQUEST\_LOW\_POWER action type. If the
value is TRUE then the *requestActionSignal* notification with a
REQUEST\_LOW\_POWER action type is sent to the application. The
Application RunTime performs default actions on behalf of the
application if the value is FALSE. The default value is FALSE.

Note that this setting will be deprecated in 5.1.5, and should only be
used for testing in 5.1.4.

No

Yes

START\_ARG

STRING

The start file in the application package to be loaded at application
launch.

Yes

Yes

SUPPORT\_SHOW

BOOLEAN

This field indicates if the application supports handling the
*requestActionSignal* for the REQUEST\_SHOW action type. If the value is
TRUE then the *requestActionSignal* notification with a REQUEST\_SHOW
action type is sent to the application. The Application RunTime performs
default actions on behalf of the application if the value is FALSE. The
default value is FALSE.

Note that this setting will be deprecated in 5.1.5, and should only be
used for testing in 5.1.4.

No

Yes

SUPPORT\_SUSPEND\_MODE

STRING

This field indicates if the application supports handling the
*requestActionSignal* for the REQUEST\_SUSPEND action type. If the value
is TRUE then the *requestActionSignal* notification with a
REQUEST\_SUSPEND action type is sent to the application. The Application
RunTime performs default actions on behalf of the application if the
value is FALSE. The default value is FALSE.

Note that this setting will be deprecated in 5.1.5, and should only be
used for testing in 5.1.4.

No

Yes

USAGE

STRING

Defines the application’s usage. This value can be used to filter
certain kinds of applications, for example “Game”, “Guide”, etc.

No

Yes

**Permission-based**

<otv:AUTHORIZATIONS>

STRING

Top-level permission element.

Yes

No

<otv:RESOURCES>

Element containing application resource permissions, using sub-elements
<otv:NETWORK>. <otv:STORAGE>, <otv:KEYS>, and
<otv:MEMORY>.

Yes

No

<otv:SERVICES>

Element containing application access permissions for individual CCOM
objects, using sub-elements <otv:PERMISSIONS>, and
<otv:\[CCOM\_Object\_Name\]>.

The sub-element <otv:ALL> is also supported, and indicates the
application has administrative permission for all CCOM objects; must be
used in conjunction with
<otv:PERMISSIONS>ADMIN</otv:PERMISSIONS> or
<otv:PERMISSIONS>\*</otv:PERMISSIONS>, which both indicate
full access. For example:

<otv:SERVICES>

<otv:ALL>

<otv:PERMISSIONS>\*</otv:PERMISSIONS>

</otv:ALL>

</otv:SERVICES>

Yes

No

 



## Key Mapping

This section summarizes SVG key mapping.

### Virtual and Physical Keys

Virtual key values are listed as actual physical key values, which are
defined in DOM virtual key codes. The translated key values are then
translated to the Unicode equivalent. For example, the virtual key
values for ‘a’ and ‘A’ are the same and they are distinguished by the
modifier, which is the SHIFT or CAPS key in this example.

From a JavaScript application point of view, the KeyboardEvent object
has three event types: keydown, keypress, keyup. Each event has
attributes including keyCode, charCode, and which.

* The ‘which’ attribute is usually the same as ‘keyCode’.

* The ‘charCode’ attribute maps to the translated Unicode equivalent key
values.

* The ‘keyCode’ attribute maps to the physical keys (DOM\_VK\_\*) and
uses modifiers to distinguish keys like ‘+’ and ‘=’.

**Remote control and keyboard key names**

**'keydown' and 'keyup' event keyCode**

CURSOR\_LEFT

0x0025

CURSOR\_RIGHT

0x0027

CURSOR\_UP

0x0026

CURSOR\_DOWN

0x0028

INSERT

0x002D

HOME

0x0024

END

0x0023

PAGE\_UP

0x0021

PAGE\_DOWN

0x0022

PRINT

0x002C

PAUSE

0x0013

OK

0xF00B

SELECT

0xF00C

GOTO

0xF00D

CLEAR

0xF00E

POWER

0xF00F

POWER2

0xF010

OPTION

0xF011

MENU

0xF012

HELP

0xF013

INFO

0xF014

TIME

0xF015

VENDOR

0xF016

ARCHIVE

0xF017

PROGRAM

0xF018

CHANNEL

0xF019

FAVORITES

0xF01A

EPG

0xF01B

PVR

0xF01C

MHP

0xF01D

LANGUAGE

0xF01E

TITLE

0xF01F

SUBTITLE

0xF020

ANGLE

0xF021

ZOOM

0xF022

MODE

0xF023

KEYBOARD

0xF024

PC

0xF025

SCREEN

0xF026

TV

0xF027

TV2

0xF028

VCR

0xF029

VCR2

0xF02A

SAT

0xF02B

SAT2

0xF02C

CD

0xF02D

TAPE

0xF02E

RADIO

0xF02F

TUNER

0xF030

PLAYER

0xF031

TEXT

0xF032

DVD

0xF033

AUX

0xF034

MP3

0xF035

PHONE

0xF036

AUDIO

0xF037

VIDEO

0xF038

INTERNET

0xF039

MAIL

0xF03A

NEWS

0xF03B

DIRECTORY

0xF03C

LIST

0xF03D

CALCULATOR

0xF03E

MEMO

0xF03F

CALENDAR

0xF040

EDITOR

0xF041

RED

0xF042

GREEN

0xF043

YELLOW

0xF044

BLUE

0xF045

CHANNEL\_UP

0xF046

CHANNEL\_DOWN

0xF047

BACK

0xF048

FORWARD

0xF049

FIRST

0xF04A

LAST

0xF04B

VOLUME\_UP

0xF04C

VOLUME\_DOWN

0xF04D

MUTE

0xF04E

AB

0xF04F

PLAYPAUSE

0xF050

PLAY

0xF051

STOP

0xF052

RESTART

0xF053

SLOW

0xF054

FAST

0xF055

RECORD

0xF056

EJECT

0xF057

SHUFFLE

0xF058

REWIND

0xF059

FASTFORWARD

0xF05A

PREVIOUS

0xF05B

NEXT

0xF05C

BEGIN

0xF05D

DIGITS

0xF05E

TEEN

0xF05F

TWEN

0xF060

BREAK

0xF061

EXIT

0xF062

SETUP

0xF063

CURSOR\_LEFT\_UP

0xF064

CURSOR\_LEFT\_DOWN

0xF065

CURSOR\_UP\_RIGHT

0xF066

CURSOR\_DOWN\_RIGHT

0xF067

F1

0x0070

F2

0x0071

F3

0x0072

F4

0x0073

F5

0x0074

F6

0x0075

F7

0x0076

F8

0x0077

F9

0x0078

F10

0x0079

F11

0x007A

F12

0x007B

SHIFT

0x0010

CONTROL

0x0011

ALT

0x0012

ALTGR

0xF208

META

0xF210

SUPER

0xF220

HYPER

0xF240

CAPS\_LOCK

0x0014

NUM\_LOCK

0x0090

SCROLL\_LOCK

0x0091

Certain remote control keys may be mapped differently depending on the
remote control or project. For example, the VOD, SEARCH, APP, and PIP
buttons are not listed in the table. In this case, use CUSTOM keys (i.e.
CUSTOM0, CUSTOM1, CUSTOM2,…) to define their mappings.

OpenTV recommends that the JavaScript application use ‘keyCode’ because
remote control keys are mapped to this.

SVG text elements use the translated key values if editable.

HTML forms use the virtual key values.

For more information about DOM KeyboardEvent, refer to [*https://developer.mozilla.org/en-US/docs/DOM/KeyboardEvent*](https://developer.mozilla.org/en-US/docs/DOM/KeyboardEvent).

### Spatial Navigation

Spatial navigation using key codes is fully supported. When the remote
control is used to change focus on screen elements, the element with
focus generates a focus event.

Some remote controllers has a “Ok”, “Select”, or “Enter” button. Most of
them are mapped to use “OK”, keycode 0xF00B.

Note that the “OK key” does not generate click event.

## Appendix: HTML Key Mappings

### HTML Key Mappings

HTML Key Mappings, in addition to the common ones described in the
[<span class="LiteralText">*Map a New Remote
Control*](http://otv5docs/CCOM5.1.4/Support/Application%20Developer's%20Guide.htm#Racbabjbfgg){.Topic}
section, are listed in the following table:

**Key Name**

**OpenTV WebKit keydown keyCode (HEX)**

**OpenTV WebKit keydown keyCode (DEC)**

**Comments**

AB

0xF04F

61519

ALT

0x12

18

ALTGR

0xF208

61960

AMPERSAND

0x37

55

HTML app needs to read modifier (i.e. shift key) fo